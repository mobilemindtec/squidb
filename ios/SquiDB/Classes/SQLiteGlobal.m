//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./build/j2objc/java/SQLiteGlobal.java
//

#include "J2ObjC_source.h"
#include "SQLiteGlobal.h"
#include "java/lang/Math.h"

#import <sqlite3.h>

#define SOFT_HEAP_LIMIT 8 * 1024 * 1024

@interface SquiDBSQLiteGlobal ()

+ (jint)nativeReleaseMemory;

- (instancetype)init;

@end

inline NSString *SquiDBSQLiteGlobal_get_TAG(void);
static NSString *SquiDBSQLiteGlobal_TAG = @"SQLiteGlobal";
J2OBJC_STATIC_FIELD_OBJ_FINAL(SquiDBSQLiteGlobal, TAG, NSString *)

__attribute__((unused)) static jint SquiDBSQLiteGlobal_nativeReleaseMemory(void);

__attribute__((unused)) static void SquiDBSQLiteGlobal_init(SquiDBSQLiteGlobal *self);

__attribute__((unused)) static SquiDBSQLiteGlobal *new_SquiDBSQLiteGlobal_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static SquiDBSQLiteGlobal *create_SquiDBSQLiteGlobal_init(void);

@implementation SquiDBSQLiteGlobal

+ (void)sqlite3_initialize {
  SquiDBSQLiteGlobal_sqlite3_initialize();
}

+ (jint)nativeReleaseMemory {
  return SquiDBSQLiteGlobal_nativeReleaseMemory();
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  SquiDBSQLiteGlobal_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (jint)releaseMemory {
  return SquiDBSQLiteGlobal_releaseMemory();
}

+ (jint)getDefaultPageSize {
  return SquiDBSQLiteGlobal_getDefaultPageSize();
}

+ (NSString *)getDefaultJournalMode {
  return SquiDBSQLiteGlobal_getDefaultJournalMode();
}

+ (jint)getJournalSizeLimit {
  return SquiDBSQLiteGlobal_getJournalSizeLimit();
}

+ (NSString *)getDefaultSyncMode {
  return SquiDBSQLiteGlobal_getDefaultSyncMode();
}

+ (NSString *)getWALSyncMode {
  return SquiDBSQLiteGlobal_getWALSyncMode();
}

+ (jint)getWALAutoCheckpoint {
  return SquiDBSQLiteGlobal_getWALAutoCheckpoint();
}

+ (jint)getWALConnectionPoolSize {
  return SquiDBSQLiteGlobal_getWALConnectionPoolSize();
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x109, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x10a, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x9, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(sqlite3_initialize);
  methods[1].selector = @selector(nativeReleaseMemory);
  methods[2].selector = @selector(init);
  methods[3].selector = @selector(releaseMemory);
  methods[4].selector = @selector(getDefaultPageSize);
  methods[5].selector = @selector(getDefaultJournalMode);
  methods[6].selector = @selector(getJournalSizeLimit);
  methods[7].selector = @selector(getDefaultSyncMode);
  methods[8].selector = @selector(getWALSyncMode);
  methods[9].selector = @selector(getWALAutoCheckpoint);
  methods[10].selector = @selector(getWALConnectionPoolSize);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 0, -1, -1 },
  };
  static const void *ptrTable[] = { &SquiDBSQLiteGlobal_TAG };
  static const J2ObjcClassInfo _SquiDBSQLiteGlobal = { "SQLiteGlobal", "com.yahoo.android.sqlite", ptrTable, methods, fields, 7, 0x11, 11, 1, -1, -1, -1, -1, -1 };
  return &_SquiDBSQLiteGlobal;
}

@end

void SquiDBSQLiteGlobal_sqlite3_initialize() {
  SquiDBSQLiteGlobal_initialize();
  // Enable multi-threaded mode.  In this mode, SQLite is safe to use by multiple
  // threads as long as no two threads use the same database connection at the same
  // time (which we guarantee in the SQLite database wrappers).
  sqlite3_config(SQLITE_CONFIG_MULTITHREAD);
  
  // The soft heap limit prevents the page cache allocations from growing
  // beyond the given limit, no matter what the max page cache sizes are
  // set to. The limit does not, as of 3.5.0, affect any other allocations.
  sqlite3_soft_heap_limit(SOFT_HEAP_LIMIT);
  
  // Initialize SQLite.
  sqlite3_initialize();
}

jint SquiDBSQLiteGlobal_nativeReleaseMemory() {
  SquiDBSQLiteGlobal_initialize();
  return sqlite3_release_memory(SOFT_HEAP_LIMIT);
}

void SquiDBSQLiteGlobal_init(SquiDBSQLiteGlobal *self) {
  NSObject_init(self);
}

SquiDBSQLiteGlobal *new_SquiDBSQLiteGlobal_init() {
  J2OBJC_NEW_IMPL(SquiDBSQLiteGlobal, init)
}

SquiDBSQLiteGlobal *create_SquiDBSQLiteGlobal_init() {
  J2OBJC_CREATE_IMPL(SquiDBSQLiteGlobal, init)
}

jint SquiDBSQLiteGlobal_releaseMemory() {
  SquiDBSQLiteGlobal_initialize();
  return SquiDBSQLiteGlobal_nativeReleaseMemory();
}

jint SquiDBSQLiteGlobal_getDefaultPageSize() {
  SquiDBSQLiteGlobal_initialize();
  return 1024;
}

NSString *SquiDBSQLiteGlobal_getDefaultJournalMode() {
  SquiDBSQLiteGlobal_initialize();
  return @"delete";
}

jint SquiDBSQLiteGlobal_getJournalSizeLimit() {
  SquiDBSQLiteGlobal_initialize();
  return 10000;
}

NSString *SquiDBSQLiteGlobal_getDefaultSyncMode() {
  SquiDBSQLiteGlobal_initialize();
  return @"normal";
}

NSString *SquiDBSQLiteGlobal_getWALSyncMode() {
  SquiDBSQLiteGlobal_initialize();
  return @"normal";
}

jint SquiDBSQLiteGlobal_getWALAutoCheckpoint() {
  SquiDBSQLiteGlobal_initialize();
  jint value = 1000;
  return JavaLangMath_maxWithInt_withInt_(1, value);
}

jint SquiDBSQLiteGlobal_getWALConnectionPoolSize() {
  SquiDBSQLiteGlobal_initialize();
  jint value = 10;
  return JavaLangMath_maxWithInt_withInt_(2, value);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SquiDBSQLiteGlobal)

J2OBJC_NAME_MAPPING(SquiDBSQLiteGlobal, "com.yahoo.android.sqlite", "SquiDB")
