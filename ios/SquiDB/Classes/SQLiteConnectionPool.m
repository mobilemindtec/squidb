//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./build/j2objc/java/SQLiteConnectionPool.java
//

#include "CloseGuard.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "Logger.h"
#include "PrefixPrinter.h"
#include "Printer.h"
#include "SQLiteConnection.h"
#include "SQLiteConnectionPool.h"
#include "SQLiteDatabase.h"
#include "SQLiteDatabaseConfiguration.h"
#include "SQLiteGlobal.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Thread.h"
#include "java/util/ArrayList.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/WeakHashMap.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "java/util/concurrent/locks/LockSupport.h"

@class SquiDBSQLiteConnectionPool_ConnectionWaiter;

@interface SquiDBSQLiteConnectionPool () {
 @public
  SquiDBCloseGuard *mCloseGuard_;
  id mLock_;
  JavaUtilConcurrentAtomicAtomicBoolean *mConnectionLeaked_;
  SquiDBSQLiteDatabaseConfiguration *mConfiguration_;
  jint mMaxConnectionPoolSize_;
  jboolean mIsOpen_;
  jint mNextConnectionId_;
  SquiDBSQLiteConnectionPool_ConnectionWaiter *mConnectionWaiterPool_;
  SquiDBSQLiteConnectionPool_ConnectionWaiter *mConnectionWaiterQueue_;
  JavaUtilArrayList *mAvailableNonPrimaryConnections_;
  SquiDBSQLiteConnection *mAvailablePrimaryConnection_;
  JavaUtilWeakHashMap *mAcquiredConnections_;
}

- (instancetype)initWithSquiDBSQLiteDatabaseConfiguration:(SquiDBSQLiteDatabaseConfiguration *)configuration;

- (void)open;

- (void)disposeWithBoolean:(jboolean)finalized;

- (jboolean)recycleConnectionLockedWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection
      withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus:(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)status;

- (SquiDBSQLiteConnection *)openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration:(SquiDBSQLiteDatabaseConfiguration *)configuration
                                                                          withBoolean:(jboolean)primaryConnection;

- (void)closeAvailableConnectionsAndLogExceptionsLocked;

- (void)closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked;

- (void)closeExcessConnectionsAndLogExceptionsLocked;

- (void)closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection;

- (void)discardAcquiredConnectionsLocked;

- (void)reconfigureAllConnectionsLocked;

- (void)markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus:(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)status;

+ (jlong)uptimeMillis;

- (SquiDBSQLiteConnection *)waitForConnectionWithNSString:(NSString *)sql
                                                  withInt:(jint)connectionFlags;

- (void)logConnectionPoolBusyLockedWithLong:(jlong)waitMillis
                                    withInt:(jint)connectionFlags;

- (void)wakeConnectionWaitersLocked;

- (SquiDBSQLiteConnection *)tryAcquirePrimaryConnectionLockedWithInt:(jint)connectionFlags;

- (SquiDBSQLiteConnection *)tryAcquireNonPrimaryConnectionLockedWithNSString:(NSString *)sql
                                                                     withInt:(jint)connectionFlags;

- (void)finishAcquireConnectionLockedWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection
                                                        withInt:(jint)connectionFlags;

- (jboolean)isSessionBlockingImportantConnectionWaitersLockedWithBoolean:(jboolean)holdingPrimaryConnection
                                                                 withInt:(jint)connectionFlags;

+ (jint)getPriorityWithInt:(jint)connectionFlags;

- (void)setMaxConnectionPoolSizeLocked;

- (void)throwIfClosedLocked;

- (SquiDBSQLiteConnectionPool_ConnectionWaiter *)obtainConnectionWaiterLockedWithJavaLangThread:(JavaLangThread *)thread
                                                                                       withLong:(jlong)startTime
                                                                                        withInt:(jint)priority
                                                                                    withBoolean:(jboolean)wantPrimaryConnection
                                                                                   withNSString:(NSString *)sql
                                                                                        withInt:(jint)connectionFlags;

- (void)recycleConnectionWaiterLockedWithSquiDBSQLiteConnectionPool_ConnectionWaiter:(SquiDBSQLiteConnectionPool_ConnectionWaiter *)waiter;

@end

J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mCloseGuard_, SquiDBCloseGuard *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mLock_, id)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mConnectionLeaked_, JavaUtilConcurrentAtomicAtomicBoolean *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mConfiguration_, SquiDBSQLiteDatabaseConfiguration *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mConnectionWaiterPool_, SquiDBSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mConnectionWaiterQueue_, SquiDBSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mAvailableNonPrimaryConnections_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mAvailablePrimaryConnection_, SquiDBSQLiteConnection *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool, mAcquiredConnections_, JavaUtilWeakHashMap *)

inline NSString *SquiDBSQLiteConnectionPool_get_TAG(void);
static NSString *SquiDBSQLiteConnectionPool_TAG = @"SQLiteConnectionPool";
J2OBJC_STATIC_FIELD_OBJ_FINAL(SquiDBSQLiteConnectionPool, TAG, NSString *)

inline jlong SquiDBSQLiteConnectionPool_get_CONNECTION_POOL_BUSY_MILLIS(void);
#define SquiDBSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS 30000LL
J2OBJC_STATIC_FIELD_CONSTANT(SquiDBSQLiteConnectionPool, CONNECTION_POOL_BUSY_MILLIS, jlong)

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteDatabaseConfiguration *configuration);

__attribute__((unused)) static SquiDBSQLiteConnectionPool *new_SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(SquiDBSQLiteDatabaseConfiguration *configuration) NS_RETURNS_RETAINED;

__attribute__((unused)) static SquiDBSQLiteConnectionPool *create_SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(SquiDBSQLiteDatabaseConfiguration *configuration);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_open(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_disposeWithBoolean_(SquiDBSQLiteConnectionPool *self, jboolean finalized);

__attribute__((unused)) static jboolean SquiDBSQLiteConnectionPool_recycleConnectionLockedWithSquiDBSQLiteConnection_withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnection *connection, SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *status);

__attribute__((unused)) static SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration_withBoolean_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteDatabaseConfiguration *configuration, jboolean primaryConnection);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnection *connection);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_discardAcquiredConnectionsLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_reconfigureAllConnectionsLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *status);

__attribute__((unused)) static jlong SquiDBSQLiteConnectionPool_uptimeMillis(void);

__attribute__((unused)) static SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(SquiDBSQLiteConnectionPool *self, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(SquiDBSQLiteConnectionPool *self, jlong waitMillis, jint connectionFlags);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(SquiDBSQLiteConnectionPool *self, jint connectionFlags);

__attribute__((unused)) static SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(SquiDBSQLiteConnectionPool *self, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnection *connection, jint connectionFlags);

__attribute__((unused)) static jboolean SquiDBSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(SquiDBSQLiteConnectionPool *self, jboolean holdingPrimaryConnection, jint connectionFlags);

__attribute__((unused)) static jint SquiDBSQLiteConnectionPool_getPriorityWithInt_(jint connectionFlags);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_throwIfClosedLocked(SquiDBSQLiteConnectionPool *self);

__attribute__((unused)) static SquiDBSQLiteConnectionPool_ConnectionWaiter *SquiDBSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(SquiDBSQLiteConnectionPool *self, JavaLangThread *thread, jlong startTime, jint priority, jboolean wantPrimaryConnection, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_recycleConnectionWaiterLockedWithSquiDBSQLiteConnectionPool_ConnectionWaiter_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnectionPool_ConnectionWaiter *waiter);

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *self, NSString *__name, jint __ordinal);

__attribute__((unused)) static SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *new_SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(NSString *__name, jint __ordinal) NS_RETURNS_RETAINED;

@interface SquiDBSQLiteConnectionPool_ConnectionWaiter : NSObject {
 @public
  SquiDBSQLiteConnectionPool_ConnectionWaiter *mNext_;
  JavaLangThread *mThread_;
  jlong mStartTime_;
  jint mPriority_;
  jboolean mWantPrimaryConnection_;
  NSString *mSql_;
  jint mConnectionFlags_;
  SquiDBSQLiteConnection *mAssignedConnection_;
  JavaLangRuntimeException *mException_;
  jint mNonce_;
}

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(SquiDBSQLiteConnectionPool_ConnectionWaiter)

J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool_ConnectionWaiter, mNext_, SquiDBSQLiteConnectionPool_ConnectionWaiter *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool_ConnectionWaiter, mThread_, JavaLangThread *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool_ConnectionWaiter, mSql_, NSString *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool_ConnectionWaiter, mAssignedConnection_, SquiDBSQLiteConnection *)
J2OBJC_FIELD_SETTER(SquiDBSQLiteConnectionPool_ConnectionWaiter, mException_, JavaLangRuntimeException *)

__attribute__((unused)) static void SquiDBSQLiteConnectionPool_ConnectionWaiter_init(SquiDBSQLiteConnectionPool_ConnectionWaiter *self);

__attribute__((unused)) static SquiDBSQLiteConnectionPool_ConnectionWaiter *new_SquiDBSQLiteConnectionPool_ConnectionWaiter_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static SquiDBSQLiteConnectionPool_ConnectionWaiter *create_SquiDBSQLiteConnectionPool_ConnectionWaiter_init(void);

J2OBJC_TYPE_LITERAL_HEADER(SquiDBSQLiteConnectionPool_ConnectionWaiter)

@implementation SquiDBSQLiteConnectionPool

+ (jint)CONNECTION_FLAG_READ_ONLY {
  return SquiDBSQLiteConnectionPool_CONNECTION_FLAG_READ_ONLY;
}

+ (jint)CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY {
  return SquiDBSQLiteConnectionPool_CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY;
}

+ (jint)CONNECTION_FLAG_INTERACTIVE {
  return SquiDBSQLiteConnectionPool_CONNECTION_FLAG_INTERACTIVE;
}

- (instancetype)initWithSquiDBSQLiteDatabaseConfiguration:(SquiDBSQLiteDatabaseConfiguration *)configuration {
  SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(self, configuration);
  return self;
}

- (void)java_finalize {
  @try {
    SquiDBSQLiteConnectionPool_disposeWithBoolean_(self, true);
  }
  @finally {
    [super java_finalize];
  }
}

+ (SquiDBSQLiteConnectionPool *)openWithSquiDBSQLiteDatabaseConfiguration:(SquiDBSQLiteDatabaseConfiguration *)configuration {
  return SquiDBSQLiteConnectionPool_openWithSquiDBSQLiteDatabaseConfiguration_(configuration);
}

- (void)open {
  SquiDBSQLiteConnectionPool_open(self);
}

- (void)close {
  SquiDBSQLiteConnectionPool_disposeWithBoolean_(self, false);
}

- (void)disposeWithBoolean:(jboolean)finalized {
  SquiDBSQLiteConnectionPool_disposeWithBoolean_(self, finalized);
}

- (void)reconfigureWithSquiDBSQLiteDatabaseConfiguration:(SquiDBSQLiteDatabaseConfiguration *)configuration {
  if (configuration == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"configuration must not be null.");
  }
  @synchronized(mLock_) {
    SquiDBSQLiteConnectionPool_throwIfClosedLocked(self);
    jboolean walModeChanged = ((configuration->openFlags_ ^ ((SquiDBSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->openFlags_) & SquiDBSQLiteDatabase_ENABLE_WRITE_AHEAD_LOGGING) != 0;
    if (walModeChanged) {
      if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"Write Ahead Logging (WAL) mode cannot be enabled or disabled while there are transactions in progress.  Finish all transactions and release all active database connections first.");
      }
      SquiDBSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
      JreAssert([((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) isEmpty], @"com/yahoo/android/sqlite/SQLiteConnectionPool.java:269 condition failed: assert mAvailableNonPrimaryConnections.isEmpty();");
    }
    jboolean foreignKeyModeChanged = configuration->foreignKeyConstraintsEnabled_ != mConfiguration_->foreignKeyConstraintsEnabled_;
    if (foreignKeyModeChanged) {
      if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"Foreign Key Constraints cannot be enabled or disabled while there are transactions in progress.  Finish all transactions and release all active database connections first.");
      }
    }
    if (mConfiguration_->openFlags_ != configuration->openFlags_) {
      if (walModeChanged) {
        SquiDBSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      }
      SquiDBSQLiteConnection *newPrimaryConnection = SquiDBSQLiteConnectionPool_openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration_withBoolean_(self, configuration, true);
      SquiDBSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      SquiDBSQLiteConnectionPool_discardAcquiredConnectionsLocked(self);
      mAvailablePrimaryConnection_ = newPrimaryConnection;
      [mConfiguration_ updateParametersFromWithSquiDBSQLiteDatabaseConfiguration:configuration];
      SquiDBSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
    }
    else {
      [mConfiguration_ updateParametersFromWithSquiDBSQLiteDatabaseConfiguration:configuration];
      SquiDBSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
      SquiDBSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(self);
      SquiDBSQLiteConnectionPool_reconfigureAllConnectionsLocked(self);
    }
    SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
  }
}

- (SquiDBSQLiteConnection *)acquireConnectionWithNSString:(NSString *)sql
                                                  withInt:(jint)connectionFlags {
  return SquiDBSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)releaseConnectionWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection {
  @synchronized(mLock_) {
    SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *status = [((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) removeWithId:connection];
    if (status == nil) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the specified connection was not acquired from this pool or has already been released.");
    }
    if (!mIsOpen_) {
      SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, connection);
    }
    else if ([((SquiDBSQLiteConnection *) nil_chk(connection)) isPrimaryConnection]) {
      if (SquiDBSQLiteConnectionPool_recycleConnectionLockedWithSquiDBSQLiteConnection_withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status)) {
        JreAssert(mAvailablePrimaryConnection_ == nil, @"com/yahoo/android/sqlite/SQLiteConnectionPool.java:366 condition failed: assert mAvailablePrimaryConnection == null;");
        mAvailablePrimaryConnection_ = connection;
      }
      SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
    else if ([((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) size] >= mMaxConnectionPoolSize_ - 1) {
      SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, connection);
    }
    else {
      if (SquiDBSQLiteConnectionPool_recycleConnectionLockedWithSquiDBSQLiteConnection_withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status)) {
        [mAvailableNonPrimaryConnections_ addWithId:connection];
      }
      SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
  }
}

- (jboolean)recycleConnectionLockedWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection
      withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus:(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)status {
  return SquiDBSQLiteConnectionPool_recycleConnectionLockedWithSquiDBSQLiteConnection_withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(self, connection, status);
}

- (jboolean)shouldYieldConnectionWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection
                                                    withInt:(jint)connectionFlags {
  @synchronized(mLock_) {
    if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) containsKeyWithId:connection]) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the specified connection was not acquired from this pool or has already been released.");
    }
    if (!mIsOpen_) {
      return false;
    }
    return SquiDBSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(self, [((SquiDBSQLiteConnection *) nil_chk(connection)) isPrimaryConnection], connectionFlags);
  }
}

- (void)collectDbStatsWithJavaUtilArrayList:(JavaUtilArrayList *)dbStatsList {
  @synchronized(mLock_) {
    if (mAvailablePrimaryConnection_ != nil) {
      [mAvailablePrimaryConnection_ collectDbStatsWithJavaUtilArrayList:dbStatsList];
    }
    for (SquiDBSQLiteConnection * __strong connection in nil_chk(mAvailableNonPrimaryConnections_)) {
      [((SquiDBSQLiteConnection *) nil_chk(connection)) collectDbStatsWithJavaUtilArrayList:dbStatsList];
    }
    for (SquiDBSQLiteConnection * __strong connection in nil_chk([((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) keySet])) {
      [((SquiDBSQLiteConnection *) nil_chk(connection)) collectDbStatsUnsafeWithJavaUtilArrayList:dbStatsList];
    }
  }
}

- (SquiDBSQLiteConnection *)openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration:(SquiDBSQLiteDatabaseConfiguration *)configuration
                                                                          withBoolean:(jboolean)primaryConnection {
  return SquiDBSQLiteConnectionPool_openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration_withBoolean_(self, configuration, primaryConnection);
}

- (void)onConnectionLeaked {
  SquiDBLogger_wWithNSString_withNSString_(SquiDBSQLiteConnectionPool_TAG, JreStrcat("$$$", @"A SQLiteConnection object for database '", ((SquiDBSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->label_, @"' was leaked!  Please fix your application to end transactions in progress properly and to close the database when it is no longer needed."));
  [((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(mConnectionLeaked_)) setWithBoolean:true];
}

- (void)closeAvailableConnectionsAndLogExceptionsLocked {
  SquiDBSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
}

- (void)closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked {
  SquiDBSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
}

- (void)closeExcessConnectionsAndLogExceptionsLocked {
  SquiDBSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(self);
}

- (void)closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection {
  SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, connection);
}

- (void)discardAcquiredConnectionsLocked {
  SquiDBSQLiteConnectionPool_discardAcquiredConnectionsLocked(self);
}

- (void)reconfigureAllConnectionsLocked {
  SquiDBSQLiteConnectionPool_reconfigureAllConnectionsLocked(self);
}

- (void)markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus:(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)status {
  SquiDBSQLiteConnectionPool_markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(self, status);
}

+ (jlong)uptimeMillis {
  return SquiDBSQLiteConnectionPool_uptimeMillis();
}

- (SquiDBSQLiteConnection *)waitForConnectionWithNSString:(NSString *)sql
                                                  withInt:(jint)connectionFlags {
  return SquiDBSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)logConnectionPoolBusyLockedWithLong:(jlong)waitMillis
                                    withInt:(jint)connectionFlags {
  SquiDBSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(self, waitMillis, connectionFlags);
}

- (void)wakeConnectionWaitersLocked {
  SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
}

- (SquiDBSQLiteConnection *)tryAcquirePrimaryConnectionLockedWithInt:(jint)connectionFlags {
  return SquiDBSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, connectionFlags);
}

- (SquiDBSQLiteConnection *)tryAcquireNonPrimaryConnectionLockedWithNSString:(NSString *)sql
                                                                     withInt:(jint)connectionFlags {
  return SquiDBSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)finishAcquireConnectionLockedWithSquiDBSQLiteConnection:(SquiDBSQLiteConnection *)connection
                                                        withInt:(jint)connectionFlags {
  SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(self, connection, connectionFlags);
}

- (jboolean)isSessionBlockingImportantConnectionWaitersLockedWithBoolean:(jboolean)holdingPrimaryConnection
                                                                 withInt:(jint)connectionFlags {
  return SquiDBSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(self, holdingPrimaryConnection, connectionFlags);
}

+ (jint)getPriorityWithInt:(jint)connectionFlags {
  return SquiDBSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
}

- (void)setMaxConnectionPoolSizeLocked {
  SquiDBSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
}

- (void)throwIfClosedLocked {
  SquiDBSQLiteConnectionPool_throwIfClosedLocked(self);
}

- (SquiDBSQLiteConnectionPool_ConnectionWaiter *)obtainConnectionWaiterLockedWithJavaLangThread:(JavaLangThread *)thread
                                                                                       withLong:(jlong)startTime
                                                                                        withInt:(jint)priority
                                                                                    withBoolean:(jboolean)wantPrimaryConnection
                                                                                   withNSString:(NSString *)sql
                                                                                        withInt:(jint)connectionFlags {
  return SquiDBSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(self, thread, startTime, priority, wantPrimaryConnection, sql, connectionFlags);
}

- (void)recycleConnectionWaiterLockedWithSquiDBSQLiteConnectionPool_ConnectionWaiter:(SquiDBSQLiteConnectionPool_ConnectionWaiter *)waiter {
  SquiDBSQLiteConnectionPool_recycleConnectionWaiterLockedWithSquiDBSQLiteConnectionPool_ConnectionWaiter_(self, waiter);
}

- (void)dumpWithSquiDBPrinter:(id<SquiDBPrinter>)printer
                  withBoolean:(jboolean)verbose {
  id<SquiDBPrinter> indentedPrinter = SquiDBPrefixPrinter_createWithSquiDBPrinter_withNSString_(printer, @"    ");
  @synchronized(mLock_) {
    [((id<SquiDBPrinter>) nil_chk(printer)) printlnWithNSString:JreStrcat("$$C", @"Connection pool for ", ((SquiDBSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->path_, ':')];
    [printer printlnWithNSString:JreStrcat("$Z", @"  Open: ", mIsOpen_)];
    [printer printlnWithNSString:JreStrcat("$I", @"  Max connections: ", mMaxConnectionPoolSize_)];
    [printer printlnWithNSString:@"  Available primary connection:"];
    if (mAvailablePrimaryConnection_ != nil) {
      [mAvailablePrimaryConnection_ dumpWithSquiDBPrinter:indentedPrinter withBoolean:verbose];
    }
    else {
      [((id<SquiDBPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Available non-primary connections:"];
    if (![((JavaUtilArrayList *) nil_chk(mAvailableNonPrimaryConnections_)) isEmpty]) {
      jint count = [mAvailableNonPrimaryConnections_ size];
      for (jint i = 0; i < count; i++) {
        [((SquiDBSQLiteConnection *) nil_chk([mAvailableNonPrimaryConnections_ getWithInt:i])) dumpWithSquiDBPrinter:indentedPrinter withBoolean:verbose];
      }
    }
    else {
      [((id<SquiDBPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Acquired connections:"];
    if (![((JavaUtilWeakHashMap *) nil_chk(mAcquiredConnections_)) isEmpty]) {
      for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([mAcquiredConnections_ entrySet])) {
        SquiDBSQLiteConnection *connection = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey];
        [((SquiDBSQLiteConnection *) nil_chk(connection)) dumpUnsafeWithSquiDBPrinter:indentedPrinter withBoolean:verbose];
        [((id<SquiDBPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:JreStrcat("$@", @"  Status: ", [entry_ getValue])];
      }
    }
    else {
      [((id<SquiDBPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
    [printer printlnWithNSString:@"  Connection waiters:"];
    if (mConnectionWaiterQueue_ != nil) {
      jint i = 0;
      jlong now = SquiDBSQLiteConnectionPool_uptimeMillis();
      for (SquiDBSQLiteConnectionPool_ConnectionWaiter *waiter = mConnectionWaiterQueue_; waiter != nil; waiter = waiter->mNext_, i++) {
        [((id<SquiDBPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:JreStrcat("I$F$@$I$$C", i, @": waited for ", ((now - waiter->mStartTime_) * 0.001f), @" ms - thread=", waiter->mThread_, @", priority=", waiter->mPriority_, @", sql='", waiter->mSql_, '\'')];
      }
    }
    else {
      [((id<SquiDBPrinter>) nil_chk(indentedPrinter)) printlnWithNSString:@"<none>"];
    }
  }
}

- (NSString *)description {
  return JreStrcat("$$", @"SQLiteConnectionPool: ", ((SquiDBSQLiteDatabaseConfiguration *) nil_chk(mConfiguration_))->path_);
}

- (void)dealloc {
  JreCheckFinalize(self, [SquiDBSQLiteConnectionPool class]);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 1, -1, 2, -1, -1, -1 },
    { NULL, "LSquiDBSQLiteConnectionPool;", 0x9, 3, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 0, -1, -1, -1, -1 },
    { NULL, "LSquiDBSQLiteConnection;", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 16, -1, 17, -1, -1 },
    { NULL, "LSquiDBSQLiteConnection;", 0x2, 18, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "J", 0x10a, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSquiDBSQLiteConnection;", 0x2, 23, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 24, 25, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSquiDBSQLiteConnection;", 0x2, 26, 27, -1, -1, -1, -1 },
    { NULL, "LSquiDBSQLiteConnection;", 0x2, 28, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 29, 14, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 30, 31, -1, -1, -1, -1 },
    { NULL, "I", 0xa, 32, 27, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSquiDBSQLiteConnectionPool_ConnectionWaiter;", 0x2, 33, 34, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 35, 36, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 37, 38, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 39, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithSquiDBSQLiteDatabaseConfiguration:);
  methods[1].selector = @selector(java_finalize);
  methods[2].selector = @selector(openWithSquiDBSQLiteDatabaseConfiguration:);
  methods[3].selector = @selector(open);
  methods[4].selector = @selector(close);
  methods[5].selector = @selector(disposeWithBoolean:);
  methods[6].selector = @selector(reconfigureWithSquiDBSQLiteDatabaseConfiguration:);
  methods[7].selector = @selector(acquireConnectionWithNSString:withInt:);
  methods[8].selector = @selector(releaseConnectionWithSquiDBSQLiteConnection:);
  methods[9].selector = @selector(recycleConnectionLockedWithSquiDBSQLiteConnection:withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus:);
  methods[10].selector = @selector(shouldYieldConnectionWithSquiDBSQLiteConnection:withInt:);
  methods[11].selector = @selector(collectDbStatsWithJavaUtilArrayList:);
  methods[12].selector = @selector(openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration:withBoolean:);
  methods[13].selector = @selector(onConnectionLeaked);
  methods[14].selector = @selector(closeAvailableConnectionsAndLogExceptionsLocked);
  methods[15].selector = @selector(closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked);
  methods[16].selector = @selector(closeExcessConnectionsAndLogExceptionsLocked);
  methods[17].selector = @selector(closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection:);
  methods[18].selector = @selector(discardAcquiredConnectionsLocked);
  methods[19].selector = @selector(reconfigureAllConnectionsLocked);
  methods[20].selector = @selector(markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus:);
  methods[21].selector = @selector(uptimeMillis);
  methods[22].selector = @selector(waitForConnectionWithNSString:withInt:);
  methods[23].selector = @selector(logConnectionPoolBusyLockedWithLong:withInt:);
  methods[24].selector = @selector(wakeConnectionWaitersLocked);
  methods[25].selector = @selector(tryAcquirePrimaryConnectionLockedWithInt:);
  methods[26].selector = @selector(tryAcquireNonPrimaryConnectionLockedWithNSString:withInt:);
  methods[27].selector = @selector(finishAcquireConnectionLockedWithSquiDBSQLiteConnection:withInt:);
  methods[28].selector = @selector(isSessionBlockingImportantConnectionWaitersLockedWithBoolean:withInt:);
  methods[29].selector = @selector(getPriorityWithInt:);
  methods[30].selector = @selector(setMaxConnectionPoolSizeLocked);
  methods[31].selector = @selector(throwIfClosedLocked);
  methods[32].selector = @selector(obtainConnectionWaiterLockedWithJavaLangThread:withLong:withInt:withBoolean:withNSString:withInt:);
  methods[33].selector = @selector(recycleConnectionWaiterLockedWithSquiDBSQLiteConnectionPool_ConnectionWaiter:);
  methods[34].selector = @selector(dumpWithSquiDBPrinter:withBoolean:);
  methods[35].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 40, -1, -1 },
    { "CONNECTION_POOL_BUSY_MILLIS", "J", .constantValue.asLong = SquiDBSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS, 0x1a, -1, -1, -1, -1 },
    { "mCloseGuard_", "LSquiDBCloseGuard;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mLock_", "LNSObject;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mConnectionLeaked_", "LJavaUtilConcurrentAtomicAtomicBoolean;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mConfiguration_", "LSquiDBSQLiteDatabaseConfiguration;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mMaxConnectionPoolSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mIsOpen_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mNextConnectionId_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mConnectionWaiterPool_", "LSquiDBSQLiteConnectionPool_ConnectionWaiter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mConnectionWaiterQueue_", "LSquiDBSQLiteConnectionPool_ConnectionWaiter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAvailableNonPrimaryConnections_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x12, -1, -1, 41, -1 },
    { "mAvailablePrimaryConnection_", "LSquiDBSQLiteConnection;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAcquiredConnections_", "LJavaUtilWeakHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 42, -1 },
    { "CONNECTION_FLAG_READ_ONLY", "I", .constantValue.asInt = SquiDBSQLiteConnectionPool_CONNECTION_FLAG_READ_ONLY, 0x19, -1, -1, -1, -1 },
    { "CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY", "I", .constantValue.asInt = SquiDBSQLiteConnectionPool_CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY, 0x19, -1, -1, -1, -1 },
    { "CONNECTION_FLAG_INTERACTIVE", "I", .constantValue.asInt = SquiDBSQLiteConnectionPool_CONNECTION_FLAG_INTERACTIVE, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LSquiDBSQLiteDatabaseConfiguration;", "finalize", "LJavaLangThrowable;", "open", "dispose", "Z", "reconfigure", "acquireConnection", "LNSString;I", "releaseConnection", "LSquiDBSQLiteConnection;", "recycleConnectionLocked", "LSquiDBSQLiteConnection;LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;", "shouldYieldConnection", "LSquiDBSQLiteConnection;I", "collectDbStats", "LJavaUtilArrayList;", "(Ljava/util/ArrayList<Lcom/yahoo/android/sqlite/SQLiteDebug$DbStats;>;)V", "openConnectionLocked", "LSquiDBSQLiteDatabaseConfiguration;Z", "closeConnectionAndLogExceptionsLocked", "markAcquiredConnectionsLocked", "LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;", "waitForConnection", "logConnectionPoolBusyLocked", "JI", "tryAcquirePrimaryConnectionLocked", "I", "tryAcquireNonPrimaryConnectionLocked", "finishAcquireConnectionLocked", "isSessionBlockingImportantConnectionWaitersLocked", "ZI", "getPriority", "obtainConnectionWaiterLocked", "LJavaLangThread;JIZLNSString;I", "recycleConnectionWaiterLocked", "LSquiDBSQLiteConnectionPool_ConnectionWaiter;", "dump", "LSquiDBPrinter;Z", "toString", &SquiDBSQLiteConnectionPool_TAG, "Ljava/util/ArrayList<Lcom/yahoo/android/sqlite/SQLiteConnection;>;", "Ljava/util/WeakHashMap<Lcom/yahoo/android/sqlite/SQLiteConnection;Lcom/yahoo/android/sqlite/SQLiteConnectionPool$AcquiredConnectionStatus;>;", "LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;LSquiDBSQLiteConnectionPool_ConnectionWaiter;" };
  static const J2ObjcClassInfo _SquiDBSQLiteConnectionPool = { "SQLiteConnectionPool", "com.yahoo.android.sqlite", ptrTable, methods, fields, 7, 0x11, 36, 17, -1, 43, -1, -1, -1 };
  return &_SquiDBSQLiteConnectionPool;
}

@end

void SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteDatabaseConfiguration *configuration) {
  NSObject_init(self);
  self->mCloseGuard_ = SquiDBCloseGuard_get();
  self->mLock_ = new_NSObject_init();
  self->mConnectionLeaked_ = new_JavaUtilConcurrentAtomicAtomicBoolean_init();
  self->mAvailableNonPrimaryConnections_ = new_JavaUtilArrayList_init();
  self->mAcquiredConnections_ = new_JavaUtilWeakHashMap_init();
  self->mConfiguration_ = new_SquiDBSQLiteDatabaseConfiguration_initWithSquiDBSQLiteDatabaseConfiguration_(configuration);
  SquiDBSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(self);
}

SquiDBSQLiteConnectionPool *new_SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(SquiDBSQLiteDatabaseConfiguration *configuration) {
  J2OBJC_NEW_IMPL(SquiDBSQLiteConnectionPool, initWithSquiDBSQLiteDatabaseConfiguration_, configuration)
}

SquiDBSQLiteConnectionPool *create_SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(SquiDBSQLiteDatabaseConfiguration *configuration) {
  J2OBJC_CREATE_IMPL(SquiDBSQLiteConnectionPool, initWithSquiDBSQLiteDatabaseConfiguration_, configuration)
}

SquiDBSQLiteConnectionPool *SquiDBSQLiteConnectionPool_openWithSquiDBSQLiteDatabaseConfiguration_(SquiDBSQLiteDatabaseConfiguration *configuration) {
  SquiDBSQLiteConnectionPool_initialize();
  if (configuration == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"configuration must not be null.");
  }
  SquiDBSQLiteConnectionPool *pool = new_SquiDBSQLiteConnectionPool_initWithSquiDBSQLiteDatabaseConfiguration_(configuration);
  SquiDBSQLiteConnectionPool_open(pool);
  return pool;
}

void SquiDBSQLiteConnectionPool_open(SquiDBSQLiteConnectionPool *self) {
  self->mAvailablePrimaryConnection_ = SquiDBSQLiteConnectionPool_openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, true);
  self->mIsOpen_ = true;
  [((SquiDBCloseGuard *) nil_chk(self->mCloseGuard_)) openWithNSString:@"close"];
}

void SquiDBSQLiteConnectionPool_disposeWithBoolean_(SquiDBSQLiteConnectionPool *self, jboolean finalized) {
  if (self->mCloseGuard_ != nil) {
    if (finalized) {
      [self->mCloseGuard_ warnIfOpen];
    }
    [self->mCloseGuard_ close];
  }
  if (!finalized) {
    @synchronized(self->mLock_) {
      SquiDBSQLiteConnectionPool_throwIfClosedLocked(self);
      self->mIsOpen_ = false;
      SquiDBSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(self);
      jint pendingCount = [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) size];
      if (pendingCount != 0) {
        SquiDBLogger_iWithNSString_withNSString_(SquiDBSQLiteConnectionPool_TAG, JreStrcat("$$$I$", @"The connection pool for ", ((SquiDBSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->label_, @" has been closed but there are still ", pendingCount, @" connections in use.  They will be closed as they are released back to the pool."));
      }
      SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
    }
  }
}

jboolean SquiDBSQLiteConnectionPool_recycleConnectionLockedWithSquiDBSQLiteConnection_withSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnection *connection, SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *status) {
  if (status == JreLoadEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE)) {
    @try {
      [((SquiDBSQLiteConnection *) nil_chk(connection)) reconfigureWithSquiDBSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      SquiDBLogger_eWithNSString_withNSString_withJavaLangThrowable_(SquiDBSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure released connection, closing it: ", connection), ex);
      status = JreLoadEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD);
    }
  }
  if (status == JreLoadEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD)) {
    SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, connection);
    return false;
  }
  return true;
}

SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration_withBoolean_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteDatabaseConfiguration *configuration, jboolean primaryConnection) {
  jint connectionId = self->mNextConnectionId_++;
  return SquiDBSQLiteConnection_openWithSquiDBSQLiteConnectionPool_withSquiDBSQLiteDatabaseConfiguration_withInt_withBoolean_(self, configuration, connectionId, primaryConnection);
}

void SquiDBSQLiteConnectionPool_closeAvailableConnectionsAndLogExceptionsLocked(SquiDBSQLiteConnectionPool *self) {
  SquiDBSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(self);
  if (self->mAvailablePrimaryConnection_ != nil) {
    SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, self->mAvailablePrimaryConnection_);
    self->mAvailablePrimaryConnection_ = nil;
  }
}

void SquiDBSQLiteConnectionPool_closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked(SquiDBSQLiteConnectionPool *self) {
  jint count = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  for (jint i = 0; i < count; i++) {
    SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, [self->mAvailableNonPrimaryConnections_ getWithInt:i]);
  }
  [self->mAvailableNonPrimaryConnections_ clear];
}

void SquiDBSQLiteConnectionPool_closeExcessConnectionsAndLogExceptionsLocked(SquiDBSQLiteConnectionPool *self) {
  jint availableCount = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  while (availableCount-- > self->mMaxConnectionPoolSize_ - 1) {
    SquiDBSQLiteConnection *connection = [self->mAvailableNonPrimaryConnections_ removeWithInt:availableCount];
    SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, connection);
  }
}

void SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnection *connection) {
  @try {
    [((SquiDBSQLiteConnection *) nil_chk(connection)) close];
  }
  @catch (JavaLangRuntimeException *ex) {
    SquiDBLogger_eWithNSString_withNSString_withJavaLangThrowable_(SquiDBSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to close connection, its fate is now in the hands of the merciful GC: ", connection), ex);
  }
}

void SquiDBSQLiteConnectionPool_discardAcquiredConnectionsLocked(SquiDBSQLiteConnectionPool *self) {
  SquiDBSQLiteConnectionPool_markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(self, JreLoadEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD));
}

void SquiDBSQLiteConnectionPool_reconfigureAllConnectionsLocked(SquiDBSQLiteConnectionPool *self) {
  if (self->mAvailablePrimaryConnection_ != nil) {
    @try {
      [self->mAvailablePrimaryConnection_ reconfigureWithSquiDBSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      SquiDBLogger_eWithNSString_withNSString_withJavaLangThrowable_(SquiDBSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure available primary connection, closing it: ", self->mAvailablePrimaryConnection_), ex);
      SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, self->mAvailablePrimaryConnection_);
      self->mAvailablePrimaryConnection_ = nil;
    }
  }
  jint count = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  for (jint i = 0; i < count; i++) {
    SquiDBSQLiteConnection *connection = [self->mAvailableNonPrimaryConnections_ getWithInt:i];
    @try {
      [((SquiDBSQLiteConnection *) nil_chk(connection)) reconfigureWithSquiDBSQLiteDatabaseConfiguration:self->mConfiguration_];
    }
    @catch (JavaLangRuntimeException *ex) {
      SquiDBLogger_eWithNSString_withNSString_withJavaLangThrowable_(SquiDBSQLiteConnectionPool_TAG, JreStrcat("$@", @"Failed to reconfigure available non-primary connection, closing it: ", connection), ex);
      SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, connection);
      (void) [self->mAvailableNonPrimaryConnections_ removeWithInt:i--];
      count -= 1;
    }
  }
  SquiDBSQLiteConnectionPool_markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(self, JreLoadEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE));
}

void SquiDBSQLiteConnectionPool_markAcquiredConnectionsLockedWithSquiDBSQLiteConnectionPool_AcquiredConnectionStatus_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *status) {
  if (![((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) isEmpty]) {
    JavaUtilArrayList *keysToUpdate = new_JavaUtilArrayList_initWithInt_([self->mAcquiredConnections_ size]);
    for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([self->mAcquiredConnections_ entrySet])) {
      SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *oldStatus = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue];
      if (status != oldStatus && oldStatus != JreLoadEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD)) {
        [keysToUpdate addWithId:[entry_ getKey]];
      }
    }
    jint updateCount = [keysToUpdate size];
    for (jint i = 0; i < updateCount; i++) {
      (void) [self->mAcquiredConnections_ putWithId:[keysToUpdate getWithInt:i] withId:status];
    }
  }
}

jlong SquiDBSQLiteConnectionPool_uptimeMillis() {
  SquiDBSQLiteConnectionPool_initialize();
  return (long) [[NSProcessInfo processInfo] systemUptime] * 1000;
}

SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_waitForConnectionWithNSString_withInt_(SquiDBSQLiteConnectionPool *self, NSString *sql, jint connectionFlags) {
  jboolean wantPrimaryConnection = (connectionFlags & SquiDBSQLiteConnectionPool_CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY) != 0;
  SquiDBSQLiteConnectionPool_ConnectionWaiter *waiter;
  jint nonce;
  @synchronized(self->mLock_) {
    SquiDBSQLiteConnectionPool_throwIfClosedLocked(self);
    SquiDBSQLiteConnection *connection = nil;
    if (!wantPrimaryConnection) {
      connection = SquiDBSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, sql, connectionFlags);
    }
    if (connection == nil) {
      connection = SquiDBSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, connectionFlags);
    }
    if (connection != nil) {
      return connection;
    }
    jint priority = SquiDBSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
    jlong startTime = SquiDBSQLiteConnectionPool_uptimeMillis();
    waiter = SquiDBSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(self, JavaLangThread_currentThread(), startTime, priority, wantPrimaryConnection, sql, connectionFlags);
    SquiDBSQLiteConnectionPool_ConnectionWaiter *predecessor = nil;
    SquiDBSQLiteConnectionPool_ConnectionWaiter *successor = self->mConnectionWaiterQueue_;
    while (successor != nil) {
      if (priority > successor->mPriority_) {
        ((SquiDBSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNext_ = successor;
        break;
      }
      predecessor = successor;
      successor = successor->mNext_;
    }
    if (predecessor != nil) {
      predecessor->mNext_ = waiter;
    }
    else {
      self->mConnectionWaiterQueue_ = waiter;
    }
    nonce = ((SquiDBSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNonce_;
  }
  @try {
    jlong busyTimeoutMillis = SquiDBSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS;
    jlong nextBusyTimeoutTime = waiter->mStartTime_ + busyTimeoutMillis;
    for (; ; ) {
      if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(self->mConnectionLeaked_)) compareAndSetWithBoolean:true withBoolean:false]) {
        @synchronized(self->mLock_) {
          SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(self);
        }
      }
      JavaUtilConcurrentLocksLockSupport_parkNanosWithId_withLong_(self, busyTimeoutMillis * 1000000LL);
      JavaLangThread_interrupted();
      @synchronized(self->mLock_) {
        SquiDBSQLiteConnectionPool_throwIfClosedLocked(self);
        SquiDBSQLiteConnection *connection = waiter->mAssignedConnection_;
        JavaLangRuntimeException *ex = waiter->mException_;
        if (connection != nil || ex != nil) {
          SquiDBSQLiteConnectionPool_recycleConnectionWaiterLockedWithSquiDBSQLiteConnectionPool_ConnectionWaiter_(self, waiter);
          if (connection != nil) {
            return connection;
          }
          @throw nil_chk(ex);
        }
        jlong now = SquiDBSQLiteConnectionPool_uptimeMillis();
        if (now < nextBusyTimeoutTime) {
          busyTimeoutMillis = now - nextBusyTimeoutTime;
        }
        else {
          SquiDBSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(self, now - waiter->mStartTime_, connectionFlags);
          busyTimeoutMillis = SquiDBSQLiteConnectionPool_CONNECTION_POOL_BUSY_MILLIS;
          nextBusyTimeoutTime = now + busyTimeoutMillis;
        }
      }
    }
  }
  @finally {
  }
}

void SquiDBSQLiteConnectionPool_logConnectionPoolBusyLockedWithLong_withInt_(SquiDBSQLiteConnectionPool *self, jlong waitMillis, jint connectionFlags) {
  JavaLangThread *thread = JavaLangThread_currentThread();
  JavaLangStringBuilder *msg = new_JavaLangStringBuilder_init();
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"The connection pool for database '"])) appendWithNSString:((SquiDBSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->label_];
  (void) [msg appendWithNSString:@"' has been unable to grant a connection to thread "];
  (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithLong:[((JavaLangThread *) nil_chk(thread)) getId]])) appendWithNSString:@" ("])) appendWithNSString:[thread getName]])) appendWithNSString:@") "];
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"with flags 0x"])) appendWithNSString:JavaLangInteger_toHexStringWithInt_(connectionFlags)];
  (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@" for "])) appendWithFloat:waitMillis * 0.001f])) appendWithNSString:@" seconds.\n"];
  JavaUtilArrayList *requests = new_JavaUtilArrayList_init();
  jint activeConnections = 0;
  jint idleConnections = 0;
  if (![((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) isEmpty]) {
    for (SquiDBSQLiteConnection * __strong connection in nil_chk([self->mAcquiredConnections_ keySet])) {
      NSString *description_ = [((SquiDBSQLiteConnection *) nil_chk(connection)) describeCurrentOperationUnsafe];
      if (description_ != nil) {
        [requests addWithId:description_];
        activeConnections += 1;
      }
      else {
        idleConnections += 1;
      }
    }
  }
  jint availableConnections = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  if (self->mAvailablePrimaryConnection_ != nil) {
    availableConnections += 1;
  }
  (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"Connections: "])) appendWithInt:activeConnections])) appendWithNSString:@" active, "];
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithInt:idleConnections])) appendWithNSString:@" idle, "];
  (void) [((JavaLangStringBuilder *) nil_chk([msg appendWithInt:availableConnections])) appendWithNSString:@" available.\n"];
  if (![requests isEmpty]) {
    (void) [msg appendWithNSString:@"\nRequests in progress:\n"];
    for (NSString * __strong request in requests) {
      (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([msg appendWithNSString:@"  "])) appendWithNSString:request])) appendWithNSString:@"\n"];
    }
  }
  SquiDBLogger_wWithNSString_withNSString_(SquiDBSQLiteConnectionPool_TAG, [msg description]);
}

void SquiDBSQLiteConnectionPool_wakeConnectionWaitersLocked(SquiDBSQLiteConnectionPool *self) {
  SquiDBSQLiteConnectionPool_ConnectionWaiter *predecessor = nil;
  SquiDBSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterQueue_;
  jboolean primaryConnectionNotAvailable = false;
  jboolean nonPrimaryConnectionNotAvailable = false;
  while (waiter != nil) {
    jboolean unpark = false;
    if (!self->mIsOpen_) {
      unpark = true;
    }
    else {
      @try {
        SquiDBSQLiteConnection *connection = nil;
        if (!waiter->mWantPrimaryConnection_ && !nonPrimaryConnectionNotAvailable) {
          connection = SquiDBSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(self, waiter->mSql_, waiter->mConnectionFlags_);
          if (connection == nil) {
            nonPrimaryConnectionNotAvailable = true;
          }
        }
        if (connection == nil && !primaryConnectionNotAvailable) {
          connection = SquiDBSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(self, waiter->mConnectionFlags_);
          if (connection == nil) {
            primaryConnectionNotAvailable = true;
          }
        }
        if (connection != nil) {
          waiter->mAssignedConnection_ = connection;
          unpark = true;
        }
        else if (nonPrimaryConnectionNotAvailable && primaryConnectionNotAvailable) {
          break;
        }
      }
      @catch (JavaLangRuntimeException *ex) {
        waiter->mException_ = ex;
        unpark = true;
      }
    }
    SquiDBSQLiteConnectionPool_ConnectionWaiter *successor = waiter->mNext_;
    if (unpark) {
      if (predecessor != nil) {
        predecessor->mNext_ = successor;
      }
      else {
        self->mConnectionWaiterQueue_ = successor;
      }
      waiter->mNext_ = nil;
      JavaUtilConcurrentLocksLockSupport_unparkWithJavaLangThread_(waiter->mThread_);
    }
    else {
      predecessor = waiter;
    }
    waiter = successor;
  }
}

SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_tryAcquirePrimaryConnectionLockedWithInt_(SquiDBSQLiteConnectionPool *self, jint connectionFlags) {
  SquiDBSQLiteConnection *connection = self->mAvailablePrimaryConnection_;
  if (connection != nil) {
    self->mAvailablePrimaryConnection_ = nil;
    SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(self, connection, connectionFlags);
    return connection;
  }
  for (SquiDBSQLiteConnection * __strong acquiredConnection in nil_chk([((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) keySet])) {
    if ([((SquiDBSQLiteConnection *) nil_chk(acquiredConnection)) isPrimaryConnection]) {
      return nil;
    }
  }
  connection = SquiDBSQLiteConnectionPool_openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, true);
  SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(self, connection, connectionFlags);
  return connection;
}

SquiDBSQLiteConnection *SquiDBSQLiteConnectionPool_tryAcquireNonPrimaryConnectionLockedWithNSString_withInt_(SquiDBSQLiteConnectionPool *self, NSString *sql, jint connectionFlags) {
  SquiDBSQLiteConnection *connection;
  jint availableCount = [((JavaUtilArrayList *) nil_chk(self->mAvailableNonPrimaryConnections_)) size];
  if (availableCount > 1 && sql != nil) {
    for (jint i = 0; i < availableCount; i++) {
      connection = [self->mAvailableNonPrimaryConnections_ getWithInt:i];
      if ([((SquiDBSQLiteConnection *) nil_chk(connection)) isPreparedStatementInCacheWithNSString:sql]) {
        (void) [self->mAvailableNonPrimaryConnections_ removeWithInt:i];
        SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(self, connection, connectionFlags);
        return connection;
      }
    }
  }
  if (availableCount > 0) {
    connection = [self->mAvailableNonPrimaryConnections_ removeWithInt:availableCount - 1];
    SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(self, connection, connectionFlags);
    return connection;
  }
  jint openConnections = [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) size];
  if (self->mAvailablePrimaryConnection_ != nil) {
    openConnections += 1;
  }
  if (openConnections >= self->mMaxConnectionPoolSize_) {
    return nil;
  }
  connection = SquiDBSQLiteConnectionPool_openConnectionLockedWithSquiDBSQLiteDatabaseConfiguration_withBoolean_(self, self->mConfiguration_, false);
  SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(self, connection, connectionFlags);
  return connection;
}

void SquiDBSQLiteConnectionPool_finishAcquireConnectionLockedWithSquiDBSQLiteConnection_withInt_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnection *connection, jint connectionFlags) {
  @try {
    jboolean readOnly = (connectionFlags & SquiDBSQLiteConnectionPool_CONNECTION_FLAG_READ_ONLY) != 0;
    [((SquiDBSQLiteConnection *) nil_chk(connection)) setOnlyAllowReadOnlyOperationsWithBoolean:readOnly];
    (void) [((JavaUtilWeakHashMap *) nil_chk(self->mAcquiredConnections_)) putWithId:connection withId:JreLoadEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL)];
  }
  @catch (JavaLangRuntimeException *ex) {
    SquiDBLogger_eWithNSString_withNSString_(SquiDBSQLiteConnectionPool_TAG, JreStrcat("$@$I", @"Failed to prepare acquired connection for session, closing it: ", connection, @", connectionFlags=", connectionFlags));
    SquiDBSQLiteConnectionPool_closeConnectionAndLogExceptionsLockedWithSquiDBSQLiteConnection_(self, connection);
    @throw ex;
  }
}

jboolean SquiDBSQLiteConnectionPool_isSessionBlockingImportantConnectionWaitersLockedWithBoolean_withInt_(SquiDBSQLiteConnectionPool *self, jboolean holdingPrimaryConnection, jint connectionFlags) {
  SquiDBSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterQueue_;
  if (waiter != nil) {
    jint priority = SquiDBSQLiteConnectionPool_getPriorityWithInt_(connectionFlags);
    do {
      if (priority > waiter->mPriority_) {
        break;
      }
      if (holdingPrimaryConnection || !waiter->mWantPrimaryConnection_) {
        return true;
      }
      waiter = waiter->mNext_;
    }
    while (waiter != nil);
  }
  return false;
}

jint SquiDBSQLiteConnectionPool_getPriorityWithInt_(jint connectionFlags) {
  SquiDBSQLiteConnectionPool_initialize();
  return (connectionFlags & SquiDBSQLiteConnectionPool_CONNECTION_FLAG_INTERACTIVE) != 0 ? 1 : 0;
}

void SquiDBSQLiteConnectionPool_setMaxConnectionPoolSizeLocked(SquiDBSQLiteConnectionPool *self) {
  if ((((SquiDBSQLiteDatabaseConfiguration *) nil_chk(self->mConfiguration_))->openFlags_ & SquiDBSQLiteDatabase_ENABLE_WRITE_AHEAD_LOGGING) != 0) {
    self->mMaxConnectionPoolSize_ = SquiDBSQLiteGlobal_getWALConnectionPoolSize();
  }
  else {
    self->mMaxConnectionPoolSize_ = 1;
  }
}

void SquiDBSQLiteConnectionPool_throwIfClosedLocked(SquiDBSQLiteConnectionPool *self) {
  if (!self->mIsOpen_) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the connection pool has been closed.");
  }
}

SquiDBSQLiteConnectionPool_ConnectionWaiter *SquiDBSQLiteConnectionPool_obtainConnectionWaiterLockedWithJavaLangThread_withLong_withInt_withBoolean_withNSString_withInt_(SquiDBSQLiteConnectionPool *self, JavaLangThread *thread, jlong startTime, jint priority, jboolean wantPrimaryConnection, NSString *sql, jint connectionFlags) {
  SquiDBSQLiteConnectionPool_ConnectionWaiter *waiter = self->mConnectionWaiterPool_;
  if (waiter != nil) {
    self->mConnectionWaiterPool_ = waiter->mNext_;
    waiter->mNext_ = nil;
  }
  else {
    waiter = new_SquiDBSQLiteConnectionPool_ConnectionWaiter_init();
  }
  waiter->mThread_ = thread;
  waiter->mStartTime_ = startTime;
  waiter->mPriority_ = priority;
  waiter->mWantPrimaryConnection_ = wantPrimaryConnection;
  waiter->mSql_ = sql;
  waiter->mConnectionFlags_ = connectionFlags;
  return waiter;
}

void SquiDBSQLiteConnectionPool_recycleConnectionWaiterLockedWithSquiDBSQLiteConnectionPool_ConnectionWaiter_(SquiDBSQLiteConnectionPool *self, SquiDBSQLiteConnectionPool_ConnectionWaiter *waiter) {
  ((SquiDBSQLiteConnectionPool_ConnectionWaiter *) nil_chk(waiter))->mNext_ = self->mConnectionWaiterPool_;
  waiter->mThread_ = nil;
  waiter->mSql_ = nil;
  waiter->mAssignedConnection_ = nil;
  waiter->mException_ = nil;
  waiter->mNonce_ += 1;
  self->mConnectionWaiterPool_ = waiter;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SquiDBSQLiteConnectionPool)

J2OBJC_NAME_MAPPING(SquiDBSQLiteConnectionPool, "com.yahoo.android.sqlite", "SquiDB")

J2OBJC_INITIALIZED_DEFN(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus)

SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_values_[3];

@implementation SquiDBSQLiteConnectionPool_AcquiredConnectionStatus

+ (SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)NORMAL {
  return JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL);
}

+ (SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)RECONFIGURE {
  return JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE);
}

+ (SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)DISCARD {
  return JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD);
}

+ (IOSObjectArray *)values {
  return SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_values();
}

+ (SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *)valueOfWithNSString:(NSString *)name {
  return SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_valueOfWithNSString_(name);
}

- (SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_Enum)toNSEnum {
  return (SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NORMAL", "LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "RECONFIGURE", "LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "DISCARD", "LSquiDBSQLiteConnectionPool_AcquiredConnectionStatus;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL), &JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE), &JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD), "LSquiDBSQLiteConnectionPool;", "Ljava/lang/Enum<Lcom/yahoo/android/sqlite/SQLiteConnectionPool$AcquiredConnectionStatus;>;" };
  static const J2ObjcClassInfo _SquiDBSQLiteConnectionPool_AcquiredConnectionStatus = { "AcquiredConnectionStatus", "com.yahoo.android.sqlite", ptrTable, methods, fields, 7, 0x4018, 2, 3, 5, -1, -1, 6, -1 };
  return &_SquiDBSQLiteConnectionPool_AcquiredConnectionStatus;
}

+ (void)initialize {
  if (self == [SquiDBSQLiteConnectionPool_AcquiredConnectionStatus class]) {
    JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, NORMAL) = new_SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(JreEnumConstantName(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_class_(), 0), 0);
    JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, RECONFIGURE) = new_SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(JreEnumConstantName(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_class_(), 1), 1);
    JreEnum(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, DISCARD) = new_SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(JreEnumConstantName(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_class_(), 2), 2);
    J2OBJC_SET_INITIALIZED(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus)
  }
}

@end

void SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}

SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *new_SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initWithNSString_withInt_(NSString *__name, jint __ordinal) {
  J2OBJC_NEW_IMPL(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus, initWithNSString_withInt_, __name, __ordinal)
}

IOSObjectArray *SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_values() {
  SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  return [IOSObjectArray arrayWithObjects:SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_values_ count:3 type:SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_class_()];
}

SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_valueOfWithNSString_(NSString *name) {
  SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  for (int i = 0; i < 3; i++) {
    SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *e = SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

SquiDBSQLiteConnectionPool_AcquiredConnectionStatus *SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_fromOrdinal(NSUInteger ordinal) {
  SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_initialize();
  if (ordinal >= 3) {
    return nil;
  }
  return SquiDBSQLiteConnectionPool_AcquiredConnectionStatus_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SquiDBSQLiteConnectionPool_AcquiredConnectionStatus)

@implementation SquiDBSQLiteConnectionPool_ConnectionWaiter

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  SquiDBSQLiteConnectionPool_ConnectionWaiter_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mNext_", "LSquiDBSQLiteConnectionPool_ConnectionWaiter;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mThread_", "LJavaLangThread;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mStartTime_", "J", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mPriority_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mWantPrimaryConnection_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mSql_", "LNSString;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mConnectionFlags_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mAssignedConnection_", "LSquiDBSQLiteConnection;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mException_", "LJavaLangRuntimeException;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mNonce_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LSquiDBSQLiteConnectionPool;" };
  static const J2ObjcClassInfo _SquiDBSQLiteConnectionPool_ConnectionWaiter = { "ConnectionWaiter", "com.yahoo.android.sqlite", ptrTable, methods, fields, 7, 0x1a, 1, 10, 0, -1, -1, -1, -1 };
  return &_SquiDBSQLiteConnectionPool_ConnectionWaiter;
}

@end

void SquiDBSQLiteConnectionPool_ConnectionWaiter_init(SquiDBSQLiteConnectionPool_ConnectionWaiter *self) {
  NSObject_init(self);
}

SquiDBSQLiteConnectionPool_ConnectionWaiter *new_SquiDBSQLiteConnectionPool_ConnectionWaiter_init() {
  J2OBJC_NEW_IMPL(SquiDBSQLiteConnectionPool_ConnectionWaiter, init)
}

SquiDBSQLiteConnectionPool_ConnectionWaiter *create_SquiDBSQLiteConnectionPool_ConnectionWaiter_init() {
  J2OBJC_CREATE_IMPL(SquiDBSQLiteConnectionPool_ConnectionWaiter, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(SquiDBSQLiteConnectionPool_ConnectionWaiter)
